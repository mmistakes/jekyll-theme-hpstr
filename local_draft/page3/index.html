<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Latest Posts &#8211; Virtual Travelog</title>
<meta name="description" content="Describe this nonsense.">
<meta name="keywords" content="complexity, system design, computer history">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="/images//site-theme/Arpanet-1977-1024w.png">

<meta name="twitter:title" content="Latest Posts">
<meta name="twitter:description" content="Describe this nonsense.">
<meta name="twitter:creator" content="@VirtualTravel">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Latest Posts">
<meta property="og:description" content="Describe this nonsense.">
<meta property="og:url" content="/page3/">
<meta property="og:site_name" content="Virtual Travelog">





<link rel="canonical" href="/page3/">
<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Virtual Travelog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<!-- Webfonts -->
<link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/images/apple-touch-icon-144x144-precomposed.png">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="/images/avatar.jpg" alt="John R. Harris photo" class="author-photo">
					<h4>John R. Harris</h4>
					<p>CTO at SPAN Digital - Engineering executive, systems architect, business and technology strategist.</p>
				</li>
				<li><a href="/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:john@virtualtravelog.net"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/VirtualTravel"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/VirtualTravelog"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				<li>
					<a href="https://linkedin.com/in/johnrharris"><i class="fa fa-fw fa-linkedin"></i> LinkedIn</a>
				</li>
				<li>
					<a href="https://github.com/VirtualTraveler"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="/posts/">All Posts</a></li>
				<li><a href="/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="/links/" >Links</a></li>
	  
	    
	    <li><a href="http://www.spandigital.com" target="_blank">SPAN Digital</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="/images//site-theme/Arpanet-1977-1024w.png" alt="Latest Posts">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Virtual Travelog</h1>
      <h2>Latest Posts</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2004-01-26T00:00:00-08:00"><a href="/2004/01/ontology-review-1-the-nhs-common-basic-specification-why-top-level-ontologies-dont-work/">January 26, 2004</a></time></span><span class="author vcard"><span class="fn"><a href="/about/" title="About John R. Harris">John R. Harris</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="/2004/01/ontology-review-1-the-nhs-common-basic-specification-why-top-level-ontologies-dont-work/" rel="bookmark" title="Ontology Review 1. The NHS Common Basic Specification. Why top level Ontologies don’t work." itemprop="url">Ontology Review 1. The NHS Common Basic Specification. Why top level Ontologies don’t work.</a></h1>
    
  </header>
  <div class="entry-content">
    <p>This is the first of an occasional series of reviews I intend to write to illustrate some important general traits of ontologies. In each review I will dissect an ontology and examine why it succeeded or failed. In this essay I mention concepts that are defined in my previous essay. <a href="2004/01/judging-the-likely-success-of-an-ontology/">Judging the likely success of an ontology</a>. This first review covers an ontology called the Common Basic Specification (CBS) that was designed in the late 1980s to bring much needed standardization and rationalization to the fragmented information management processes of the British National Health Service (NHS). It persisted in various forms until the late 1990′s when it was finally abandoned. This is my explanation of why it failed.</p>

<p>I have been living in the US now for 6 years and have come to recognize a common reaction among Americans whenever the NHS is mentioned. They all try to hide it, but a patronizing look comes over them. It doesn’t matter how much you tell them that doctors in the NHS wash before they go into surgery, and even use anesthetics these days, Americans just can’t help feeling sorry for anyone who has to suffer under a 3 rd world healthcare system. So before I explain the CBS it is probably worth describing the NHS.</p>

<h2 id="background">Background</h2>

<p>The NHS is the largest employer in Europe it is the main provider of healthcare for the entire United Kingdom (pop 60 million). It’s annual budget is about 5 to 6 percent of the GDP of the United Kingdom. In 2002 that amounted to about 64 billion GBP which at current exchange rates is approximately 115 billion USD. By contrast the US spends about 15 percent of its GDP on healthcare and Americans live on average one year longer than the British. A more detailed breakdown of staffing and budget allocation for the NHS is available here. Primary healthcare in the UK is delivered through about 10,000 General Practices and about 2000 Hospitals, most with less than 100 beds. There are a few large Hospitals with up to 1000 beds, these larger hospitals are usually teaching Hospitals. All these numbers are approximate but they give a general idea of the scale of the NHS.</p>

<p>In the late 1980s it became apparent that the same information management problems were being encountered over and over again in hospital after hospital throughout the UK. Not only that, but they were being solved poorly time and time again. This was obviously wasteful. Hospitals had no reason to compete in the area of information management and every reason to cooperate. If these common problems could be solved correctly and then reused significant savings might be realized. At the same time the digital patient record became the holy grail of healthcare computing. In this vision of the future any patients complete medical history would be available anywhere it was needed and could be passed from GP practice to Hospital and back. It could even follow a patient as s/he moved around the country. The Common Basic Specification was suggested as the best way to ensure consistency across multiple solutions and thus enable standardization and portability of the digital patient record.</p>

<h2 id="the-common-basic-specification">The Common Basic Specification</h2>

<blockquote>
  <p>The Common Basic Specification ( CBS ) is a conceptual generic model of the activity of health care delivery.</p>

  <p>[IT Standards Handbook - NHS Data Standards]</p>
</blockquote>

<p>Definition of the NHS Data Model was started in 1986 and continued for several years. It was eventually renamed the Common Basic Specification (CBS). By 1992 a CBS Generic Model had been published. This was in effect a top level ontology (similar to the SUMO currently under development). It was developed for healthcare service delivery but it as can be seen from the diagram below it was universally applicable to any kind of service delivery.</p>

<div align="center">







<figure>
    
    <a href="/images/2004-01-CBS.png"><img src="/images/2004-01-CBS.png" alt="" /></a>
    
    <figcaption>Common Basic Specification</figcaption>
</figure>

</div>

<blockquote>
  <p><strong>Class descriptions for the figure</strong></p>

  <ul>
    <li><strong>Act for subject:</strong> An “Activity” that is directed towards a “Subject”.</li>
    <li><strong>Activity:</strong> Purposeful and intentional “Event”</li>
    <li><strong>Activity class:</strong> A kind of “Activity”.</li>
    <li><strong>Agent:</strong> Role assumed by a “Subject” enabling it to act purposefully</li>
    <li><strong>Authorised to perform:</strong> The recording of the fact that an “Agent” may perform certain classes of “Activity”.</li>
    <li><strong>Category:</strong> Abstraction on the basis of common properties.</li>
    <li><strong>Concept:</strong> “Object” which is a unit of thought.</li>
    <li><strong>Event:</strong> Something which happens.</li>
    <li><strong>Incident:</strong> “Event” occurring without known volition.</li>
    <li><strong>Knowledge concept:</strong> A collection of “Concepts”, the relationships between them and the reasons for them.</li>
    <li><strong>Located at:</strong> A “Location” for a “Subject”.</li>
    <li><strong>Location:</strong> Point or piece of space.</li>
    <li><strong>Object:</strong> Part of the conceivable or perceivable universe</li>
    <li><strong>Percept:</strong> Perceived or inferred to exist</li>
    <li><strong>Reason for activity:</strong> The identification of a “Subject property” as the reason for performing or planning an “Activity for &gt; subject”.</li>
    <li><strong>Reference point:</strong> Point or piece of time or space.</li>
    <li><strong>Responsible for:</strong> The responsibility that an “Agent” has for a “Subject”.</li>
    <li><strong>Results in:</strong> A means of establishing that an “Activity for subject” has resulted in a “Subject property”.</li>
    <li><strong>Subject:</strong> “Percept” which is one or more physical objects.</li>
    <li><strong>Subject property:</strong> Anything that describes a subject:** location, identity, characteristic etc..</li>
    <li><strong>Timepoint:</strong> Point or span of time.</li>
  </ul>

</blockquote>

<p>The initial publication of the CBS was found to be too high level. The model was hurriedly reworked and republished in 1993 as a series of CBS Application views one of which was later renamed the CBS Clinical View. This view was a slightly lower level ontology. After nearly 5 years and 5 million GBP had been invested in the model it was decided to use it as the foundation for a series of “demonstrator projects”. This work began in 1992/3. I was involved in the largest of these projects where the CBS was to be used as the foundation for an entire Hospital Information Support System. This system was to cover every aspect of hospital information management: patient master index, inpatient and outpatient management, orders and results reporting, , maternity, pharmacy, and many other ancillary activities including; clinical laboratories, laundry, and facilities management. By using the CBS as a conceptual model the final system was intended to be reusable across the NHS and be fully “future-proofed”. The system took almost 3 years to build and while it was successful in the first hospital it was only reused once.</p>

<p>In 1998, 3 years after the Hospital Information Support System was completed the model was redefined yet again and renamed the NHS Healthcare Model (HcM). But by this point it was too late. No one believed in the blue fairy of future proofing anymore and the model was abandoned. It is no longer even available online from any official NHS website. However, last year I downloaded a copy in anticipation of writing this article. So here is <a href="/projects/Ontology/CBS/default.htm#Index">The Common Basic Specification (CBS) a.k.a. The NHS Healthcare Model (HcM)</a>. Take a look around and try drilling down on some of the diagrams to get a real flavor of the model. (If you want a complete copy just send me an email and I will send a zipped file. Please don’t over stress my poor machine by downloading the whole thing.)</p>

<p>As ontologies go the Common Basic Specification is large and complex, which is not surprising given its scope and the length of time it took to develop. The CBS was reworked and refined until it became a clean conceptual model for generic service delivery. It is; coherent – logical in the relationship of its parts, generic enough to handle any healthcare delivery use case, and it is mature – the corners have been knocked off. So why did it fail?</p>

<h2 id="reasons-for-failure-of-the-common-basic-specification">Reasons for Failure of the Common Basic Specification</h2>

<p>Of the Millions of pounds spent on developing the CBS very little was spent on articulating the benefits of implementing a common standard or training people to use the model. Many potential beneficiaries of the model did not see the value of training staff to understand it. Implementing an ontology is a political activity. It requires persuasion, coercion and sometimes direct threats. Small specialized groups can be persuaded to agree on large complex ontologies but large groups find such agreement difficult and often impossible. It is almost as if there was a law governing the adoption of ontologies.</p>

<blockquote>
  <p>The size and complexity of an ontology is inversely proportional to the size and complexity of the community of agents that can be persuaded to adopt it.</p>
</blockquote>

<p>But there is a more fundamental problem with top level ontologies that is not political. At higher levels of abstraction every conceptual model is subjective; there is always another way to model reality. It can be advantageous to deliberately take a contrary view precisely because it will lead to different conclusions that may offer competitive advantage over others. The field of Healthcare delivery is large enough to accommodate many different world views. The CBS failed because it was the fossilization of a single world view.</p>

<p>Finally the Common Basic Specification took a top down reductionist approach to a fundamentally bottom up emergent problem. This same fundamental error is made by all top level ontologies. It is being made today by the developers of <a href="http://www.adampease.org/OP/">SUMO</a>, an ontology doomed to the same fate as the CBS. As a professional body the <a href="http://grouper.ieee.org/groups/">IEEE</a> ought to know better. A top down reductionist approach is useful for constrained problem domains but it is the wrong strategy for broad areas of knowledge. Robert Graves understood the tradeoff between a top down and a bottom up and explained it better than I ever could in his poem In Broken Images.</p>

<blockquote>
  <h3 id="in-broken-images">In Broken Images</h3>

  <p>He is quick, thinking in clear images; 
I am slow, thinking in broken images.</p>

  <p>He becomes dull, trusting to his clear images; 
I become sharp, mistrusting my broken images,</p>

  <p>Trusting his images, he assumes their relevance; 
Mistrusting my images, I question their relevance.</p>

  <p>Assuming their relevance, he assumes the fact, 
Questioning their relevance, I question the fact.</p>

  <p>When the fact fails him, he questions his senses;
When the fact fails me, I approve my senses.</p>

  <p>He continues quick and dull in his clear images;
I continue slow and sharp in my broken images.</p>

  <p>He in a new confusion of his understanding;
I in a new understanding of my confusion.</p>

  <p>Robert Graves</p>
</blockquote>


  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2004-01-19T00:00:00-08:00"><a href="/2004/01/judging-the-likely-success-of-an-ontology/">January 19, 2004</a></time></span><span class="author vcard"><span class="fn"><a href="/about/" title="About John R. Harris">John R. Harris</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="/2004/01/judging-the-likely-success-of-an-ontology/" rel="bookmark" title="Judging the likely Success of an Ontology" itemprop="url">Judging the likely Success of an Ontology</a></h1>
    
  </header>
  <div class="entry-content">
    <p>The debate about the promised value of the Semantic Web seems to me to be missing a dispassionate examination of the success, or otherwise, of existing ontology based solutions. Clay Shirky is obviously right when he states that <a href="http://www.shirky.com/writings/semantic_syllogism.html">a single monolithic ontology will never work</a>. His critics are equally right when they claim the Semantic web will only work if it is a melange of multiple interoperable Ontologies. What is missing from the debate is a more detailed explanation of what ontologies are good at, how they interoperate, and why systems based on ontologies succeed or fail. From my perspective as a systems designer this last point is the most significant. Debates about theory are nice, but examples of real solutions are more instructive. This essay will begin to examine this question by attempting to define the anatomy of an ontology. I will use this structure in later essays to examine the reasons for success and failure of individual ontologies.</p>

<p>Ontologies are nice, in theory, but difficult to extract value from, in practice. They fail for a variety of reasons: The fundamental assumptions on which they are based are often unsound. Sometimes they are inflexible and unable to adapt to new circumstances. Or, conversely, while attempting to make them adaptable their designers make them too abstract for the people who are then burdened with their implementation. Frequently they are inadequately specified, leaving vital areas open to interpretation, thus negating their usefulness. And just as frequently they are designed without consideration for interoperability with other ontologies – ironic considering their basic purpose. Despite all these opportunities for failure successful ontologies can be spectacularly powerful.</p>

<p>To analyze the success or failure of example ontologies it will be necessary to first define the anatomy or architecture of an ontology. By defining the roles and responsibilities of the component parts of an ontology it will be possible to explain the success or failure of various examples in terms of these components. Ontologies can vary widely in complexity. Some contain all the components listed below but many do not. The anatomy I develop below is based on practical experience of what has worked in systems I have designed, reviewed, or studied. This anatomy may not; be consistent with text books, agree with the latest theory, or reflect current best practice. It does however work for me. It may work for you, but I make no promises.</p>

<h2 id="ontologies-in-theory">Ontologies in Theory</h2>

<p>Tom Gruber of Stanford University <a href="http://www-ksl.stanford.edu/kst/what-is-an-ontology.html">defines the word Ontology</a> as :-</p>

<blockquote>
  <p>A specification of a conceptualization. That is, an ontology is a description (like a formal specification of a program) of the concepts and relationships that can exist for an agent or a community of agents.</p>
</blockquote>

<p>An Ontology can be thought of as a contract shared between agents that intend to exchange information. The contract takes the form of a model for structuring and interpreting exchanged data and a vocabulary that constrains these exchanges. Using a relatively small ontology agents can exchange vast quantities of data and consistently interpret it to extract information. Furthermore they can, in principle, infer new information by applying logical rules allowed, and sometimes explicitly specified, by the Ontology.</p>

<p>It is worth remembering that every non-trivial ontology will allow logical inconsistencies. As Godel pointed out in his Incompleteness Theorem – In any axiomatic system it is possible to create propositions that cannot be proved or disproved. This does not negate the usefulness of ontologies just as it does not negate the usefulness of mathematics. However it does mean ontologies, like everything else, have their limitations.</p>

<p>The sense of the word “Ontology” defined above was defined by the Artificial Intelligence research community after they stole the word from the field of philosophy. More recently it has been adopted to describe components of the Semantic Web. In the AI community the ability to infer new information from existing data is of fundamental importance and this is sometimes misinterpreted as a defining feature of an ontology. In fact many ontologies support this capability only weakly, if at all. The word is also sometimes narrowly defined to mean hierarchical taxonomies or constrained vocabularies, this usage is too narrow since an ontology also contains assertions about how data can be structured and interpreted and these assertions are missing from taxonomies and constrained vocabularies.</p>

<p>The following brief summary taken from the essay <a href="http://infogrid.org/trac/wiki/Reference/PidcockArticle?story=20030115211223271">What are the differences between a vocabulary, a taxonomy, a thesaurus, an ontology, and a meta-model?</a> by Johannes Ernst provides a good description of the various frameworks often classified as ontologies.</p>

<blockquote>
  <p>Taxonomies and Thesauri may relate terms in a controlled vocabulary via parent-child and associative relationships, but do not contain explicit grammar rules to constrain how to use controlled vocabulary terms to express (model) something meaningful within a domain of interest. A meta-model is an ontology used by modelers. People make commitments to use a specific controlled vocabulary or ontology for a domain of interest</p>
</blockquote>

<p>For the purpose of this essay I will use a broad definition for the word ontology</p>

<blockquote>
  <p><strong>Ontology</strong> :- A specification of a conceptualization used by a community of agents to support the exchange and consistent use of information.</p>
</blockquote>

<h2 id="ontologies-in-practice">Ontologies in Practice</h2>

<p>Ontologies, far from being an unproven new concept, are already in practical daily use. They form the foundation of classification systems, databases, and object oriented software applications. In a few notable cases ontologies have persisted and even evolved over many decades. What is new is the realization that all these seemingly different systems can be compared from an ontological point of view. With the rise of the Internet and the more recent global adoption of the Web the desire to discover and exchange information, rather than mere data, has grown. Developing methods to allow the interoperation of existing and new ontologies has become imperative – hence the efforts being expended on the development of the Semantic Web.</p>

<h2 id="ontologies-in-context">Ontologies in Context</h2>

<p>The value of an ontology can only be judged by its ability to support the exchange of information between agents. An ontology considered outside its context of use is a meaningless abstraction. It is only when a number of agents agree to use the same ontology to constrain their interactions that it gains any value. Most ontologies, especially successful ones, are less than perfect. Every useful ontology is a compromise between the conflicting needs of different agents. To fully appreciate the ability of an ontology to successfully support the exchange of information it is necessary to examine the instance data that is exchanged. All too often ontologies are presented in isolation as if they were the end of the story when in fact they are only the beginning of the dialog. The exchange is what is important not the ontology. For this reason I also include the instance data in the discussion below even though it is strictly not part of an ontology. It is worth noting that use cases are an essential part of ontology design. An ontology provided without supporting use cases is likely to be a failure.</p>

<h2 id="general-purpose-and-single-purpose-ontologies">General Purpose and Single Purpose Ontologies</h2>

<p>There are two basic types of ontology :- General purpose and single purpose. A General purpose ontology is analogous to a Universal Turing Machine in that it is capable of defining any other arbitrary ontology just as a Universal Turing Machine is capable of defining any other arbitrary Turing machine. General purpose ontologies are also capable of defining themselves. Self-definition is an significant capability because it provides for auto-discovery by both programmers and programs.</p>

<p>For example, a program or programmer that can read and understand xml schema is theoretically capable of examining the definition of the xml language (<a href="https://www.w3.org/TR/xmlschema-1/#normative-schemaSchema">itself written in xml</a>) and auto-discovering new features should they be introduced at some point in the future. Thus programmers and programs need only be taught one ontology definition language if that language is auto-defining. Codd understood this need for self-definition when he specified rule 4 of his <a href="https://en.wikipedia.org/wiki/Codd's_12_rules">12 rules</a>.</p>

<blockquote>
  <p>Codds Rule 4 – Active online catalog based on the relational model</p>

  <p>The system is required to support an online, inline, relational catalog that is accessible to authorized users by means of their regular query language.</p>
</blockquote>

<p>And if you don’t believe relational databases are ontologies you should read this.</p>

<p>Self-definition is only one of the benefits of general purpose ontologies. The other is the ability to define new arbitrarily complex ontologies. Paul Rendell has used John Conway’s <a href="http://www.cpdee.ufmg.br/~seixas/PaginaATR/Download/DownloadFiles/MathematicalGames.pdf">game of life</a> (a set of rules defining a simple tile game) to implement a <a href="http://rendell-attic.org/gol/tm.htm">Turing machine</a>. This mind boggling example proves that the game of life is Turing complete and neatly illustrates how massive complexity can arise from a very simple specification. Another similar example is the <a href="http://www.unidex.com/turing/utm.xsl.htm">XSLT Turing machine</a>. In this example XSLT itself defined in XML is used to define a Turing Machine.</p>

<p>Self definition and the ability to define arbitrarily complex ontologies is more than a party-trick. Consider the C programming language. The first C compiler was written in a programming language called B by Dennis Ritchie. The first thing he wrote in C was another C compiler which he compiled using the compiler written in B. He then created another executable compiler from the same C source code this time using the new pure C compiler. Since he now had the source code for a C compiler written in C and an executable version of that same code he was free of the B language forever.</p>

<p>General purpose ontologies capable of self definition have existed for a century at the most and have only had any practical application outside mathematics and philosophy since the widespread adoption of the computer in the 1960′s and 70′s. Special purpose ontologies are a different matter. There are many successful special purpose ontologies that are not defined by any formal language (yet) but are never-the-less formally defined. I will examine several of these in later entries but for the time being two examples will illustrate their value.</p>

<p><a href="http://www.rsc.org/periodic-table">The periodic table</a> is a classic widely used taxonomy. It becomes an ontology when it is combined with the following assertions and constants. (Please forgive me for any errors in these rules I am not a chemist.)</p>

<ul>
  <li>A molecule is the smallest quantity of a compound composed of chemically bonded elements</li>
  <li>A chemical reaction occurs when reactants (elements and/or molecules) combine to produce products (elements and/or molecules) of different composition</li>
  <li>Mass is conserved in a chemical reaction</li>
  <li>Elements cannot be transmuted in a chemical reaction</li>
  <li>A Mole of any compound is the product of the Avogadro number and the sum of the atomic masses of its constituent elements</li>
</ul>

<p>This classic chemistry ontology has withstood the attacks of scientist and abuse of school children for 200 years. It allows chemists to test the plausibility of any possible chemical reaction and predict the quantities of reaction products. The system is not perfect it cannot predict if reactions are thermodynamically likely, and it cannot predict some element properties, for example <a href="http://www.madsci.org/posts/archives/may97/862179191.Ch.r.html">why Mercury is a liquid</a>, but it can rule out many implausible chemical reactions. Most spectacularly it has been used to infer the existence of undiscovered elements and compounds.</p>

<p>The <a href="https://www.rad.org.uk/study/Benesh">Benesh Movement Notation</a> is an ontology with a very different purpose. It is a system for recording any form of human movement. Expert Choreologists can use the notation to record entire ballets with multiple, interacting performers so that other choreologist can recreate the ballet in high fidelity without the original choreographer being present. The system records human movement symbolically on a musical stave so that the movements can be synchronized with a musical accompaniment. The system is superior to video since it can record the intentions of the original choreographer rather than the individual interpretation created by a particular performer.</p>

<p>Special purpose ontologies are common. Some are widely used and some are very specialized, many are successful. All these ontologies will gradually be defined by general purpose ontology definition languages so they can be made to interoperate with other similar or overlapping ontologies. By studying these successful and in some cases long-lived ontologies we can learn a great deal about how to make the semantic web successful. Even interoperability of ontologies is not a new problem (more on interoperability in a later entry).</p>

<h2 id="anatomy-of-an-ontology-a-five-layer-model">Anatomy of an Ontology. A Five Layer Model</h2>

<p>It may be claimed that the model presented here is really a three layer model and that layers 0 and 4 are not strictly part of an ontology. This is true but it is necessary to consider all five layers when evaluating an ontology since they all affect the fitness for purpose of the complete solution.</p>

<h3 id="layer-0-ontology-definition-language">Layer 0. Ontology Definition Language</h3>

<p>The days of informally defined special purpose ontologies are over. From now on anyone taking the trouble to define an ontology will use a formal specification language. All the existing special purpose ontologies will gradually be re-defined using one of the available languages. The question is which one? There are legitimate reasons for having more than one language – different language bestow different qualities on the ontologies they define. It is still early days for many of these languages and today there are few, if any, experts who can make truly informed choices. A few general observations can be made.</p>

<p>Ontology specification languages are not a mature technology. They are still evolving. It is likely that there will be several generations of these languages just as there were several generations of programming languages. The languages in use today will be replaced by “better” languages tomorrow. We can already see this happening, SGML has largely given way to XML and XML may in turn give way to RDF or OWL at least for certain uses. A well designed ontology has the potential to retain its usefulness for a long time and so may need to be migrated from one specification language to another. Languages that are better able to support interoperability will be a safer choice since ontologies specified with them will be easier to migrate to new “better” languages.</p>

<p>In choosing an ontology specification language it should be remembered the relational data model and SQL have been the default choice for the past 25 years. This approach has been phenomenally successful. There is no doubt that it works and there is plenty of support for the model in terms of tools and expertise. It is no coincidence however, that new ontology specification languages are emerging just as the web has made the Internet ubiquitous. Relational databases work well on isolated servers where encapsulation of tightly coupled data and functionality are a benefit and applications interacting with the database can be strictly controlled. But smearing a relational database across multiple unreliably networked machines is to not a good idea. It can be done, but it isn’t pretty. The new languages (XML,RDF,OWL,etc) are designed to support exactly this kind of distribution. When functionality and data are distributed, loosely coupled, and independently controlled an ontology specification language will be a much better choice.</p>

<h3 id="layer-1-data-structures">Layer 1. Data Structures</h3>

<p>All ontologies specify data structures. Depending on the specification language selected these could be; tables containing columns, classes with slots, statements of the form: subject, predicate, object or one of several other basic formats. Whatever language is chosen a conceptual model must be developed that defines a set of data structures that is fit for the intended use. This process is the most influential factor in determining the quality of any solution subsequently designed to use the ontology. Support for flexibility, reliability, maintainability and many other qualities is either designed into the ontology or neglected at this point. Desirable qualities such as these are frequently weakened during later stages by poor development practices, but, even good development practices will not put these qualities back in if they were never there in the first place.</p>

<p>In a previous essay on <a href="/2003/01/software-design-reviews-lessons-learned-and-best-practices/">system design reviews</a> I defined a set of axioms for good conceptual modeling. I have reproduced them here in summary form below. They apply equally to ontology design since an otology is merely a specification of a conceptualization.</p>

<ol>
  <li>Everything in moderation and nothing to excess</li>
  <li>A good system design is based on a sound conceptual model (Architecture)</li>
  <li>A sound conceptual model accounts for all system requirements at a reasonable level of abstraction
    <ol>
      <li>A conceptual model is sufficiently generalized when it can account for all significant use cases in a concise way that reduces complexity by consolidating similar features</li>
      <li>A conceptual model is sufficiently specific when it is possible to demonstrate how a system design based on the model will achieve measurable targets for required system attributes</li>
    </ol>
  </li>
  <li>
    <p>A good conceptual model is easy to communicate</p>

    <ol>
      <li>A conceptual model is easier to understand and communicate if it is coherent – Logical in the relationship of it’s parts – Aesthetically consistent.</li>
      <li>A conceptual model is easier to understand and communicate if it is analogous to a commonly experienced, tangible, real world system
 	3. A conceptual model is easier to understand and communicate if it is anthropomorphized – Made to mimic human behavior, characteristics and modes of interaction</li>
    </ol>
  </li>
</ol>

<h3 id="layer-2-assertions-and-constraints">Layer 2. Assertions and Constraints</h3>

<p>Data structures only implement part of a conceptual model. An ontology also contains a set of assertions and constraints. These assertions and constraints define rules concerning the relationships between data structures and the way the data they contain can be used.</p>

<ul>
  <li><strong>Integrity Constraints</strong> define what it means for operational data to be well formed or well structured. These constraints define the rules controlling validity of data such as uniqueness of; objects, records, or statements, and the cardinality and optionality of allowed relationships. Simpler constraints defined the data types for individual items like dates, numbers and specially formatted strings.</li>
  <li><strong>Inference Constraints</strong> define how operational data can be combined and manipulated to produce new information – inferences. In most software applications these rules are usually static and embedded in the code and not directly accessible to other applications. However one of the features of ontology specification languages designed to support Artificial Intelligence systems is their ability to explicitly specify these rules so that external systems can learn them.</li>
</ul>

<h3 id="layer-3-reference-data">Layer 3. Reference Data</h3>

<p>Many ontologies specify reference data in the form of constrained vocabularies, taxonomies, or thesauri. These data are used as components and classifiers of the operational data that is exchanged between agents. Agents agree on the meaning of reference data beforehand and thus can interpret exchanged messages or statements without ambiguity. Implicit in this use of reference data is the assumption that changes to the reference data will be infrequent as they will likely require version changes of the entire ontology. This is a non-trivial happening. Modification to a previously agreed constrained vocabulary may require many agents to change the way they interpret and process data and should be avoided if possible. Significant effort should be expended on considering the consequence of changes to reference data. It is too easy to ignore such issues and assume someone else will deal with problem should they arise.</p>

<h3 id="layer-4-operational-data">Layer 4. Operational Data</h3>

<p>Operational data, sometimes also called instance data, is supported by it’s ontology but is not part of it. The purpose of the ontology is to provide structure for the operational data. As a result it is necessary to consider the operational data when evaluating an ontology. It is my experience that there are two general types of operational data.</p>

<ul>
  <li>
    <p><strong>Configuration Data.</strong> This data supports the required degree of flexibility in the solution by allowing certain features to be reconfigured. Systems that make a special feature of this type of flexibility are often called data driven, In a banking solution the types of bank account and the data relating to interest rates associated with each account could be considered configuration data. This is not the same as reference data. Configuration data is expected to change and must not require a version change of the ontology. In a hospital solution configuration data may describe the wards in the hospital and the bed compliment on each ward. All agents in such a system expect these things change over time and must be capably of reconfiguring the way they process data accordingly.</p>
  </li>
  <li>
    <p><strong>Activity Data.</strong> Management of activity data is the main reason for the existence of any ontology. Activity data includes the actual exchanges of messages and statements between agents that have agreed to use the ontology. Without activity data everything that goes before is pointless. In a banking environment activity data could describe the opening or closing of an accounts or the actual deposits and withdrawals. In a health care setting activity data could describe clinical interventions; the x-rays and blood test performed on a patient, or at a slightly higher level the inpatient stays and diagnoses.</p>
  </li>
</ul>

<h2 id="summary">Summary</h2>

<p>The success or failure of any ontology should be judged primarily by it’s ability to support the exchange of operational activity data between agents. This can only be confirmed after the ontology is implemented by assessing how the system performs in the context of use. To reduce the risk of failure in the early stages of specification the various components of the ontology should be assessed individually and collectively in terms of their ability to support required use cases for operational activity data. The design of any ontology should be assessed in terms of the following components</p>

<ol>
  <li>Ontology Definition Language</li>
  <li>Data Structures</li>
  <li>Assertions and Constraints
    <ol>
      <li>Integrity Constraints</li>
      <li>Inference Constraints</li>
    </ol>
  </li>
  <li>Reference Data</li>
  <li>Operational Data
    <ol>
      <li>Configuration Data</li>
      <li>Activity Data</li>
    </ol>
  </li>
</ol>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2003-12-29T00:00:00-08:00"><a href="/2003/12/source-code-as-history/">December 29, 2003</a></time></span><span class="author vcard"><span class="fn"><a href="/about/" title="About John R. Harris">John R. Harris</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="/2003/12/source-code-as-history/" rel="bookmark" title="Source Code as History" itemprop="url">Source Code as History</a></h1>
    
  </header>
  <div class="entry-content">
    <p>When the history of early software development is written it will be a travesty. Few historians will have the ability, and even fewer the inclination, to learn long dead programming languages. History will be derived from the documentation not the source code. Alan Turings perplexed, hand written annotation “How did this happen?” on a cutting of Autocode taped into his <a href="http://www.chstm.manchester.ac.uk/research/nahc/contents/">note book</a> will remain a mystery.</p>

<div align="center">







<figure>
    
    <a href="/images/2003-12-How.png"><img src="/images/2003-12-How.png" alt="" /></a>
    
    <figcaption>How did this happen? Annotation of a program bug by Alan Turing</figcaption>
</figure>

</div>

<p>What kind of bug would stump Alan Turing? Was it merely a typo that took a few hours to find? a simple mistake maybe? Or did the discipline of the machine expose a fundamental misconception and thereby teach him a lesson? The only way to know would be to learn Autocode.</p>

<div align="center">







<figure>
    
    <a href="/images/2003-12-Turing_Bug.png"><img src="/images/2003-12-Turing_Bug.png" alt="" /></a>
    
    <figcaption>Page from Alan Turing's notebook showing an annotated program with a bug</figcaption>
</figure>

</div>

<p>The first stored program to be successfully executed was written by Tom Kilburn and executed on Monday 21 st June 1948 at Manchester University, England. It is said that this was the first and last program that Kilburn ever wrote. The program found the highest factor of a number and took 1 minute to complete on it’s first run. A second run with a different number took 2 minutes and 52 seconds. Unfortunately no one thought to document the program until Geoffrey C. Tootill wrote an amended version in his <a href="http://www.chstm.manchester.ac.uk/research/nahc/contents/">note book</a> a month later on the 18 th July 1948. The original has been lost. Below is a copy of Tootill’s version.</p>

<div align="center">







<figure>
    
    <a href="/images/2003-12-First_Program.png"><img src="/images/2003-12-First_Program.png" alt="" /></a>
    
    <figcaption>Page from Geoffrey C. Tootill's notebook showing his amended version of the first, successfully executed, stored program</figcaption>
</figure>

</div>

<p><a href="http://www.chstm.manchester.ac.uk/downloads/media,38917,en.pdf">Via The National Archive for the History of Computing</a></p>


  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2003-11-29T00:00:00-08:00"><a href="/2003/11/linksys-befw11s4-wireless-b-broadband-router-problems-low-reliability-and-poor-fault-tolerance/">November 29, 2003</a></time></span><span class="author vcard"><span class="fn"><a href="/about/" title="About John R. Harris">John R. Harris</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="/2003/11/linksys-befw11s4-wireless-b-broadband-router-problems-low-reliability-and-poor-fault-tolerance/" rel="bookmark" title="Linksys BEFW11S4 Wireless-B Broadband Router Problems – Low Reliability and Poor Fault Tolerance" itemprop="url">Linksys BEFW11S4 Wireless-B Broadband Router Problems – Low Reliability and Poor Fault Tolerance</a></h1>
    
  </header>
  <div class="entry-content">
    <h2 id="background">Background</h2>

<div style="float:left; margin:10px;">
<p></p>
<a href="http://www.amazon.com/exec/obidos/ASIN/B00005ARK3/virtualtravel-20"><img src="/images/2003-11_BEFW11S4_v4.jpg" alt="Linksys BEFW11S4 Wireless-B Broadband Router" /></a>
</div>

<p>A few months ago I had to setup a home office and decided I would take the opportunity to upgrade my home network. My Linksys BEFSR41 Etherfast Cable / DSL Router had never given me any problems and so I decided to upgrade to the Linksys BEFW11S4 Wireless-B broadband Router. I now have everything working reliably but getting to this happy state and resolving the problems took a lot of luck and in the end the solution was far from obvious. Judging by the bad reviews on Amazon and elsewhere it appears that many people have been unable to fix similar problems with this device. Below is my description of the problem and a solution that worked for me. Hopefully this will help others, but as always, your mileage may vary!</p>

<h2 id="configuration">Configuration</h2>

<p>I have two Macs running OSX on my home network, both machines have static IP addresses and are wired to the router. I wanted to add a wireless Windows Laptop with a DHCP assigned IP address. I purchased a Linksys BEFW11S4 Wireless-B broadband Router and at the same time I bought a Proxim ORiNOCO Gold 802.11a/b/g ComboCard for the Laptop this came with a Proxim client utility. Installation and setup of the laptop card was very easy. Simply plug in the card, insert the disc and install the driver. The card immediately picked up my neighbors open network and I was on the Internet. Setting up the router was a bit more challenging; I copied the configuration from my previous device and enabled DHCP to start issuing IP numbers out of range of my 2 static machines. Everything worked and I was connected to the Internet via my new router.</p>

<h2 id="symptoms">Symptoms</h2>

<p>The wireless network seemed to work fine for several days but then it “hung”. The only fix was to turn off the router and turn it back on again. This hang affected all machines connected to the router. Whenever they attempted any network operations they would time out. However the Proxim client utility and the laptop claimed the wireless network was still running! The network hung once or twice a week – Annoying, but tolerable. Then I upgraded the laptop from windows 2000 to XP and things got worse! The network would hang one or two times a day. At first I did not connect the OS upgrade with the router problems, besides, I had another bigger issue.</p>

<p>I connect to work via a Cisco VPN client which seemed to be working ok but all of a sudden (in fact immediately after the XP upgrade), Microsoft Exchange slowed to glacial speed. It would take hours to sync with the Exchange Server. This was not acceptable. I had to fix things. I called our company technical support and got through to the guy who manages the VPN. He said “What order did you install the wireless card driver and the VPN client? Because they don’t play nice together and you must install the wireless card driver first and then the VPN client”.</p>

<h2 id="solution">Solution</h2>

<ol>
  <li>Download and install the latest firmware upgrade from Linksys. This is not enough to fix the problem on its own. I tried this first and the network still hung. But it’s a good idea and this solution may not work without it.</li>
  <li>Uninstall the Cisco VPN client and the Proxim client utility from the laptop</li>
  <li>Reinstalled the Proxim client utility on the laptop</li>
  <li>Reinstalled the Cisco VPN client on the laptop
Outcome</li>
</ol>

<p>The network has been running for 10 days without a single hitch.</p>

<h2 id="cause">Cause</h2>

<p>I’m still not certain what the cause was but this is what I suspect. The VPN client and Proxim client utility share something in common dlls or configuration or something! When installed in the wrong order things get messed up and in unusual circumstances the laptop sends network traffic that is somehow malformed. This affects the router and causes it to hang. Basically the router appears to be intolerant of glitches in low level network messages and this leads to low reliability. Not a great explanation I know and it may be completely spurious but my network now works reliably so I’m happy!</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2003-11-27T00:00:00-08:00"><a href="/2003/11/the-evolution-of-the-modern-computer-1934-to-1950-an-open-source-graphical-history/">November 27, 2003</a></time></span><span class="author vcard"><span class="fn"><a href="/about/" title="About John R. Harris">John R. Harris</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="/2003/11/the-evolution-of-the-modern-computer-1934-to-1950-an-open-source-graphical-history/" rel="bookmark" title="The Evolution of the Modern Computer (1934 to 1950): An Open Source Graphical History" itemprop="url">The Evolution of the Modern Computer (1934 to 1950): An Open Source Graphical History</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Some time between 1934 and 1950 the first modern computer was created. Pinning down exactly when that event occured is not easy. It depends on how you define the term computer and what you think is more important: The concept, the design, the first succesful test, or the first time the machine solved a real problem. In those early days it usually took years for a team to progress from concept through design to working machine. There were many such teams working mainly in the US and UK. These teams competed and cooperated somtimes they shared ideas and designs, and they sent representatives to visit each others laboratories. On one famous occassion in the Summer of 1946 almost all the leaders in the field got together at <a href="/2003/10/the-moore-school-lectures-and-the-british-lead-in-stored-program-computer-development-1946-1953/">the Moore School for an 8 week long series of lectures</a>. In short the story of the emergence of the modern computer is a complex one that involves both direct and indirect contributions from many people.</p>

<p>There are many Computer History Timelines in existence. But all of these suffer from the same flaws. They are incomplete and thier linear nature fails to capture the complex web of influence that was the hallmark of computer development.</p>

<div align="center">







<figure>
    
    <a href="/images/2003-11_EarlyComputers_lrg_V0.2.png"><img src="/images/2003-11_EarlyComputers_lrg_V0.2.png" alt="" /></a>
    
    <figcaption>The Evolution of Early Computers</figcaption>
</figure>

</div>

<p>Downloadable files available here</p>

<p>In an effort to visualize this web of interaction. I have started to develop a graphical representation of the evolution of the modern computer. Fortunately AT&amp;T have kindly released a package called Graphviz which is capable of drawing complex directed graphs. The graph above is produced by Graphviz from a text file.</p>

<p>The text file contains a detailed description of my approach, the classification I have used, and lists all the machines and the references to the data sources I used. I have not duplicated that information here because the whole point of the exercise is to gather all the data in one place.</p>

<p>I have licensed this file with an attribution, share alike creative commons license. So please feel free to download and improve what I have started. If you do make changes please send me a copy and I will share the updates on this page.</p>

<p>For the record. I believe that <a href="/2003/08/the-first-modern-computer-the-case-for-baby-the-manchester-mk-i-prototype/">The Manchester Mk I Prototype was the first Computer in a modern sense</a>. But the text file is not intended to prove this or any other machine was first. It is only intended to record the known dates and influences for computing machines designed between 1934 and 1950. I Believe that the graph is complex enough to support many interpretations.</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="/page2/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="">1</a></li>
    

    
    

    
    
    

    
      
        
        
        
        <li><a href="/page2/">2</a></li>
      
    
      
        <li><strong class="current-page">3</strong></li>
      
    
      
        
        
        
        <li><a href="/page4/">4</a></li>
      
    
      
        
        
        
        <li><a href="/page5/">5</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="/page11/">11</a></li>
    

    
    
      <li><a href="/page4/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">Virtual Travelog</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="http://www.virtualtravelog.net/" property="cc:attributionName" rel="cc:attributionURL">John R. Harris</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.

  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/assets/js/scripts.min.js"></script>



          

</body>
</html>